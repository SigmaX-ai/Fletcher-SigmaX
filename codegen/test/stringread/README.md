# Hardware simulation of Fletcher designs: Stringread example

This is a simple example of how to use **fletchgen** to generate a design based on an Arrow Schema.

## Prerequisites

* Build and install [fletchgen](../../../README.md).
* Install some simulator like QuestSim or GHDL.

## Input files

There are two input files for **fletchgen** in the [input](input/) folder of this example.

#### [input/stringread.fbs](input/stringread.fbs)

This is an Arrow Schema saved as a Flatbuffer file. You can supply multiple schemas to Fletchen, but for this we will 
only read some strings from a single Arrow RecordBatch with random names of people.

A textual representation of the schema would look as follows:
 
```
Schema metadata (key, value):
  * "fletcher_mode" = "read"
             
Field 0: 
  * Name     : "Name"
  * Type     : utf8 
  * Metadata : "epc" = "4"
```

The schema is very simple, but there are two key-value-pairs of metadata attached at specific places.
* **"fletcher_mode"** is attached to the Schema itself. Setting this to "read" means that the generated kernel is supposed 
to read from the Arrow RecordBatch based on this schema.
* **"epc"** is attached to the first field with the name "Name". This will cause the hardware stream generated based on 
  this field to deliver at most four *elements per cycle*.

#### [input/names.rb](input/names.rb)

This is a RecordBatch with some random names confirming to the schema described before.

# Runing fletchgen

We can run now run fletchgen with the "--help" argument to see what sort of options we can supply.
```console
fletchgen --help
```

Let's assume we want to use VHDL as our output language. 
After inspecting the options, we can run fletchgen for this example as follows.

 ```console
fletchgen -i input/stringread.fbs -r input/names.rb -s output/stringread.srec -l vhdl --sim
```

This basically means, use the aforementioned input files (the schema and the recordbatch), output the contents for the
memory model as an SREC file at the specified location, use VHDL as an output language and generate a simulation 
top-level.

This will produce the following files:

| File                                  | Description                                                                                   |
|---------------------------------------|-----------------------------------------------------------------------------------------------|
| vhdl/Kernel.vhdt                      | Kernel template                                                                               |
| vhdl/StringRead_RecordBatchReader.vhd | A component instantiating all ArrayReaders for every Arrow Array (column) of the RecordBatch. |
| vhdl/Kernel_Mantle.vhd                | A wrapper around the Kernel, RecordBatchReaders and bus interconnect.                         |
| vhdl/sim_top.vhd                      | Simulation (testbench) top-level                                                              |
| output/stringread.srec                | An SREC file with the contents of the RecordBatch for the memory model in simulation.         |

Note that the "vhdl/Kernel.vhdt" file was only generated because there is already an existing "vhdl/Kernel.vhd". By
default, fletchgen will not overwrite that file, but will only overwrite any existing "vhdl/Kernel.vhdt".

Now, sim_top.vhd can be simulated. There is a TCL script for QuestaSim. You can run it from this folder as follows:

```console
vsim -batch -do questa/stringread.tcl
```

After QuestaSim has compiled all Fletcher hardware and files generated by fletchgen, you should see the Kernel 
outputting the strings:
 
```
# String 0 : Alice
# String 1 : Bob
# String 2 : Carol
# String 3 : David
# String 4 : Eve
...
```

You can run QuestaSim in GUI mode to see the waveforms too. 
```console
vsim -do questa/stringread.tcl
```

You can verify that the string lengths and characters of the names appear on the two streams that were generated from
the "Names" field. Just set the character stream radix to ASCII.

```tcl
property wave -radix ASCII *chars_data
```

You should see the waveforms as below. Because we have used "epc" = "4" as metadata on the "Names" field, you can see
that the "Name_chars" signal contains 32 bits (four bytes). QuestaSim shows 32'a in front of ASCII strings, so the first
handshake delivers "cilA" to us, where from the "Name_chars_count" field we can see that all four bytes are part of the
data. Because the string "Alice" terminates after "e", the next handshake delivers "XXXe" (where X is undefined) with a
count of 1. That means only the first (rightmost) byte is part of the string. The "Name_chars_last" signal is also
asserted to signal that this is the last handshake for this string.

![Example output](doc/example.png)
